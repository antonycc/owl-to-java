package uk.co.polycode.owltojava.test

import org.simpleframework.xml.core.Persister
import uk.co.polycode.owltojava.*
import uk.co.polycode.owltojava.rdf.RdfDocument
import java.io.BufferedReader
import java.math.BigDecimal
import java.math.BigInteger
import java.net.URL
import java.nio.file.Paths
import java.time.ZonedDateTime
import kotlin.test.*

/**
 * OWL to Java generates Source Code from the W3C Web Ontology Language (OWL)
 * Copyright (C) 2022  Antony Cartwright, Polycode Limited
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * Mozilla Public License, v. 2.0 for more details.
 */
internal class GradleTaskTest {

    private val srcTestResources = "./src/test/resources"
    private val minimalOwlFilePath = Paths.get("${srcTestResources}/schemaorg-minimal-person.owl")
    private val wholeOwlFilePath = Paths.get("${srcTestResources}/schemaorg.owl")
    private val javaSourceDirectoryPath = Paths.get("./build/generated-sources")
    private val javaBasePackage = "uk.co.polycode"
    private val licenceText = """
        This file was generated by OWL to Java as a transformation of the Schema.org schema Version 14.0.
        Schema.org is released under the Creative Commons Attribution-ShareAlike License (version 3.0). 
        The Schema.org license is applicable to the generated source files and the license is available from 
        https://creativecommons.org/licenses/by-sa/3.0/
        """.trimIndent()
    private val lang = "en"
    private val classes = listOf(
        "https://schema.org/Person",
        "https://schema.org/City",
        "https://schema.org/Place",
        "https://schema.org/Corporation",
        "https://schema.org/Project",
        "https://schema.org/Book",
        "https://schema.org/Article",
        "https://example.com/NoLang",
        "https://schema.org/Fake"
    )
    private val primitivePropertyTypes = mapOf(
        "https://schema.org/DataType" to Object::class.java.name,
        "https://schema.org/Text"     to String::class.java.name,
        "https://schema.org/Time"     to ZonedDateTime::class.java.name,
        "https://schema.org/DateTime" to ZonedDateTime::class.java.name,
        "https://schema.org/Date"     to ZonedDateTime::class.java.name,
        "https://schema.org/URL"      to URL::class.java.name,
        "https://schema.org/Integer"  to BigInteger::class.java.name,
        "https://schema.org/Float"    to BigDecimal::class.java.name,
        "https://schema.org/Number"   to BigDecimal::class.java.name,
        "https://schema.org/Boolean"  to "java.lang.Boolean", // Boolean::class.java.name, unboxes to boolean.
    )
    private val ignoredPropertyTypes = listOf(
        "https://schema.org/Role"
    )
    private val prunedPropertyTypes = listOf(
        "https://schema.org/Text",
        "https://schema.org/URL"
    )
    private val ignoredSuperclasses = listOf(
        "http://www.w3.org/2000/01/rdf-schema#Class"
    )

    @Test
    fun testJavaSourceFileInOutput() {

        // Expected results
        val expectedClassName = "Person"
        val expectedSuperclassName = "Thing"
        val expectedOutputFilePath = "${javaSourceDirectoryPath}/uk/co/polycode/org/schema/${expectedClassName}.java"
        val expectedOutputFile = Paths.get(expectedOutputFilePath).toFile()

        // Setup
        val rdfDocument: RdfDocument = with(wholeOwlFilePath.toFile()){
            Persister().read(RdfDocument::class.java, this, false)
        }
        val ontologyClasses = OwlParser(rdfDocument = rdfDocument).also {
            it.classes = this.classes
            it.ignoredPropertyTypes = this.ignoredPropertyTypes
            it.prunedPropertyTypes = this.prunedPropertyTypes
        }
            .buildClassMap()
            .filter { it.key.id !in primitivePropertyTypes.keys }
        val javaSourceBuilder = JavaSourceBuilder(javaBasePackage = javaBasePackage).also {
            it.lang = this.lang
            it.licenceText = this.licenceText
            it.desiredClasses = this.classes
            it.primitivePropertyTypes = this.primitivePropertyTypes
            it.prunedPropertyTypes = this.prunedPropertyTypes
            it.ignoredSuperclasses = this.ignoredSuperclasses
        }

        // Execution
        // TODO: Move to companion object for static invocation
        JavaSourceWriter().writeClassMapAsJavaSource(
            javaSourceDirectoryPath.toFile().absolutePath,
            javaSourceDirectoryPath.toFile(),
            ontologyClasses,
            javaSourceBuilder
        )

        // Class validation
        assertTrue(expectedOutputFile.exists())
        val bufferedReader: BufferedReader = expectedOutputFile.bufferedReader()
        val javaSourceFile = bufferedReader.use { it.readText() }
        assertTrue { javaSourceFile.contains("public class ${expectedClassName}") }
        assertTrue {
            javaSourceFile.contains(
                "public class ${expectedClassName} extends ${expectedSuperclassName} {"
            )
        }
        assertTrue {
            javaSourceFile.contains(
                "public String isDefinedBy = \"https://schema.org/${expectedClassName}\";"
            )
        }
        assertTrue { javaSourceFile.contains("public String additionalName;") }
        assertTrue { javaSourceFile.contains("public PostalAddress address;") }
        assertTrue { javaSourceFile.contains("public Person funder;") }
        assertTrue { javaSourceFile.contains("public Organization funderOrganization;") }
        assertTrue { javaSourceFile.contains("public ZonedDateTime birthDate;") }
        assertTrue { javaSourceFile.contains("public String telephone;") }
        assertTrue { javaSourceFile.contains("public QuantitativeValue weight;") }
    }

    @Test
    fun testJavaSourceFileWithDefaults() {

        // Expected results
        val expectedClassName = "Person"
        val expectedSuperclassName = "Thing"
        val expectedOutputFilePath = "${javaSourceDirectoryPath}/uk/co/polycode/org/schema/${expectedClassName}.java"
        val expectedOutputFile = Paths.get(expectedOutputFilePath).toFile()

        // Setup
        val rdfDocument: RdfDocument = with(wholeOwlFilePath.toFile()){
            Persister().read(RdfDocument::class.java, this, false)
        }
        val ontologyClasses = OwlParser(rdfDocument = rdfDocument)
            .buildClassMap()
            .filter { it.key.id !in primitivePropertyTypes.keys }
        val javaSourceBuilder = JavaSourceBuilder(javaBasePackage = javaBasePackage).also {
            it.primitivePropertyTypes = this.primitivePropertyTypes
        }

        // Execution
        // TODO: Move to companion object for static invocation
        JavaSourceWriter().writeClassMapAsJavaSource(
            javaSourceDirectoryPath.toFile().absolutePath,
            javaSourceDirectoryPath.toFile(),
            ontologyClasses,
            javaSourceBuilder
        )

        // Class validation
        assertTrue(expectedOutputFile.exists())
        val bufferedReader: BufferedReader = expectedOutputFile.bufferedReader()
        val javaSourceFile = bufferedReader.use { it.readText() }
        assertTrue { javaSourceFile.contains("public class ${expectedClassName}") }
        assertTrue {
            javaSourceFile.contains(
                "public class ${expectedClassName} extends ${expectedSuperclassName} {"
            )
        }
        assertTrue {
            javaSourceFile.contains(
                "public String isDefinedBy = \"https://schema.org/${expectedClassName}\";"
            )
        }
        assertTrue { javaSourceFile.contains("public String additionalName;") }
        assertTrue { javaSourceFile.contains("public PostalAddress addressPostalAddress;") }
        assertTrue { javaSourceFile.contains("public Person funderPerson;") }
        assertTrue { javaSourceFile.contains("public Organization funder;") }
        assertTrue { javaSourceFile.contains("public ZonedDateTime birthDate;") }
        assertTrue { javaSourceFile.contains("public String telephone;") }
        assertTrue { javaSourceFile.contains("public QuantitativeValue weight;") }
    }

    @Test
    fun testJavaSourceFileNotWritten() {

        // Expected results
        val expectedClassName = "Person"
        val expectedOutputFilePath = "${javaSourceDirectoryPath}/do/not/reuse/between/tests/${expectedClassName}.java"
        val expectedOutputFile = Paths.get(expectedOutputFilePath).toFile()

        // Setup
        val taskDelegate = RegenerateOntologyTaskDelegate(
            src = minimalOwlFilePath.toFile().absolutePath,
            dest = "",
            javaBasePackage = javaBasePackage)
            .also {
                it.lang = this.lang
                it.licenceText = this.licenceText
                it.classes = this.classes
                it.primitivePropertyTypes = this.primitivePropertyTypes
                it.ignoredPropertyTypes = this.ignoredPropertyTypes
                it.prunedPropertyTypes = this.prunedPropertyTypes
                it.ignoredSuperclasses = this.ignoredSuperclasses
            }

        // Execution
        taskDelegate.regenerateJavaSource()

        // Primitive validation
        assertTrue(!expectedOutputFile.exists())
    }

    /**
     *  Gradle Task
     *  @since("Commit hash: c616f30060a429080fb516d1eb715af20865ce28")
     */
    @Test
    fun testJavaSourceFileInOutputWithPrimitives() {

        // Expected results
        val expectedClass = "Place"
        val outputFilePath = "${javaSourceDirectoryPath}/uk/co/polycode/org/schema/${expectedClass}.java"
        val outputFile = Paths.get(outputFilePath).toFile()

        // Setup
        val taskDelegate = RegenerateOntologyTaskDelegate(
            src = wholeOwlFilePath.toFile().absolutePath,
            dest = javaSourceDirectoryPath.toFile().absolutePath,
            javaBasePackage = javaBasePackage)
            .also {
                it.lang = this.lang
                it.licenceText = this.licenceText
                it.classes = this.classes
                it.primitivePropertyTypes = this.primitivePropertyTypes
                it.ignoredPropertyTypes = this.ignoredPropertyTypes
                it.prunedPropertyTypes = this.prunedPropertyTypes
                it.ignoredSuperclasses = this.ignoredSuperclasses
            }

        // Execution
        taskDelegate.regenerateJavaSource()

        // Validation
        assertNotNull(RegenerateOntologyTask::class.java)
        assertNotNull(RegenerateOntologyCli::class.java)
        assertTrue(outputFile.exists())
        val bufferedReader: BufferedReader = outputFile.bufferedReader()
        val javaSourceFile = bufferedReader.use { it.readText() }
        assertTrue { javaSourceFile.contains("public class ${expectedClass}") }
        assertTrue { javaSourceFile.contains("public GeoShape geoGeoShape;") }
        assertTrue { javaSourceFile.contains("public PostalAddress address;") }
        assertTrue { javaSourceFile.contains("public DefinedTerm keywords;") }
        assertTrue { javaSourceFile.contains("public BigDecimal latitude;") }
        assertTrue { javaSourceFile.contains("public BigDecimal longitude;") }
        assertTrue { javaSourceFile.contains("public OpeningHoursSpecification openingHoursSpecification;") }
        assertTrue { javaSourceFile.contains("public Photograph photo;") }
        assertTrue { javaSourceFile.contains("public ImageObject photoImageObject;") }
        assertTrue { javaSourceFile.contains("public BigInteger maximumAttendeeCapacity;") }
        assertTrue { javaSourceFile.contains("public Boolean publicAccess;") }
    }

    /**
     * Gradle Task with default arguments
     *
     * @since("Commit hash: 2ce90b1eff2e7746ebf96f0dbfd82e668510b505")
     */
    @Test
    fun testJavaSourceFileInOutputWitDefaults() {

        // Expected results
        val expectedClass = "Place"
        val outputFilePath = "${javaSourceDirectoryPath}/uk/co/polycode/org/schema/${expectedClass}.java"
        val outputFile = Paths.get(outputFilePath).toFile()

        // Setup
        val taskDelegate = RegenerateOntologyTaskDelegate(
            src = wholeOwlFilePath.toFile().absolutePath,
            dest = javaSourceDirectoryPath.toFile().absolutePath,
            javaBasePackage = javaBasePackage).also {
            it.primitivePropertyTypes = this.primitivePropertyTypes
        }

        // Execution
        taskDelegate.regenerateJavaSource()

        // Validation
        assertTrue(outputFile.exists())
        val bufferedReader: BufferedReader = outputFile.bufferedReader()
        val javaSourceFile = bufferedReader.use { it.readText() }
        assertTrue { javaSourceFile.contains("public class ${expectedClass}") }
        assertTrue { javaSourceFile.contains("public GeoShape geoGeoShape;") }
        assertTrue { javaSourceFile.contains("public PostalAddress addressPostalAddress;") }
        assertTrue { javaSourceFile.contains("public DefinedTerm keywords;") }
        assertTrue { javaSourceFile.contains("public BigDecimal latitudeBigDecimal;") }
        assertTrue { javaSourceFile.contains("public BigDecimal longitude;") }
        assertTrue { javaSourceFile.contains("public OpeningHoursSpecification openingHoursSpecification;") }
        assertTrue { javaSourceFile.contains("public Photograph photo;") }
        assertTrue { javaSourceFile.contains("public ImageObject photoImageObject;") }
        assertTrue { javaSourceFile.contains("public BigInteger maximumAttendeeCapacity;") }
        assertTrue { javaSourceFile.contains("public Boolean publicAccess;") }
    }

    /**
     * Test detects duplicated field names where the field name is generated from 2 classes mapped to the same primitive
     *
     * /Users/antony/projects/libschemaorg/src/main/java/uk/co/polycode/schemaorg/org/schema/Offer.java:347:
     * error:
     * variable availabilityEndsZonedDateTime is already defined in class uk.co.polycode.schemaorg.org.schema.Offer
     * public ZonedDateTime availabilityEndsZonedDateTime;
     *                      ^
     * /Users/antony/projects/libschemaorg/src/main/java/uk/co/polycode/schemaorg/org/schema/Offer.java:362:
     * error:
     * variable availabilityStartsZonedDateTime is already defined in class uk.co.polycode.schemaorg.org.schema.Offer
     * public ZonedDateTime availabilityStartsZonedDateTime;
     *                      ^
     * @since("Commit hash: 6c00cc11c84725ca4472979a48988a031c166fdd")
     */
    @Test
    fun testNoDuplicateFieldNames() {

        // Expected results
        val expectedClass = "Offer"
        val outputFilePath = "${javaSourceDirectoryPath}/uk/co/polycode/org/schema/${expectedClass}.java"
        val outputFile = Paths.get(outputFilePath).toFile()
        val expectedSingleField = "availabilityEndsZonedDateTime"

        // Setup
        val taskDelegate = RegenerateOntologyTaskDelegate(
            src = wholeOwlFilePath.toFile().absolutePath,
            dest = javaSourceDirectoryPath.toFile().absolutePath,
            javaBasePackage = javaBasePackage).also {
            it.primitivePropertyTypes = this.primitivePropertyTypes
        }

        // Execution
        taskDelegate.regenerateJavaSource()

        // Validation
        assertTrue(outputFile.exists())
        val bufferedReader: BufferedReader = outputFile.bufferedReader()
        val javaSourceFile = bufferedReader.use { it.readText() }
        assertTrue { javaSourceFile.contains("public class ${expectedClass}") }
        assertTrue { javaSourceFile.contains(expectedSingleField) }
        val matches = countMatches(javaSourceFile,expectedSingleField)
        assertTrue { matches == 1 }
    }

    /**
     * Test detects illegal Superclass (which was replaced by a Primitive so not defined but still used as a superclass)
     *
     * /Users/antony/projects/libschemaorg/src/main/java/uk/co/polycode/schemaorg/org/schema/CssSelectorType.java:17:
     * error: cannot find symbol
     * public class CssSelectorType extends Text {
     *                                      ^
     * symbol: class Text
     * /Users/antony/projects/libschemaorg/src/main/java/uk/co/polycode/schemaorg/org/schema/XPathType.java:17:
     * error: cannot find symbol
     * public class XPathType extends Text {
     *                                ^
     * symbol: class Text
     *
     * @since("Commit hash: 1f2204db95a8c3efbf2f7d62756c4b94dd0b22ee")
     */
    @Test
    fun testNoTextSuperclass() {

        // Expected results
        val expectedClass = "XPathType"
        val outputFilePath = "${javaSourceDirectoryPath}/uk/co/polycode/org/schema/${expectedClass}.java"
        val outputFile = Paths.get(outputFilePath).toFile()
        val unexpectedSingleField = "extends Text"

        // Setup
        val taskDelegate = RegenerateOntologyTaskDelegate(
            src = wholeOwlFilePath.toFile().absolutePath,
            dest = javaSourceDirectoryPath.toFile().absolutePath,
            javaBasePackage = javaBasePackage)
            .also { it.primitivePropertyTypes = this.primitivePropertyTypes }

        // Execution
        taskDelegate.regenerateJavaSource()

        // Validation
        assertTrue(outputFile.exists())
        val bufferedReader: BufferedReader = outputFile.bufferedReader()
        val javaSourceFile = bufferedReader.use { it.readText() }
        assertTrue { javaSourceFile.contains("public class ${expectedClass}") }
        assertFalse { javaSourceFile.contains(unexpectedSingleField) }
    }

    @Test
    fun testCountMatches() {

        // Expected results
        val sampleString = "AABBCCBB"
        val expectedNoMatch = "XX"
        val expectedOneMatch = "AA"
        val expectedOneMatch2 = "CC"
        val expectedTwoMatch = "BB"

        // Setup

        // Execution

        // Validation
        assertEquals(0, countMatches(sampleString, expectedNoMatch))
        assertEquals(1, countMatches(sampleString, expectedOneMatch))
        assertEquals(1, countMatches(sampleString, expectedOneMatch2))
        assertEquals(0, countMatches(expectedNoMatch, expectedOneMatch))
        assertEquals(2, countMatches(sampleString, expectedTwoMatch))
    }

    private fun countMatches(s: String, sub: String): Int = with(s.indexOf(sub)){
        if ( this == -1 )
            0
        else
            1 + countMatches(s.substring(this + sub.length), sub)
    }
}
