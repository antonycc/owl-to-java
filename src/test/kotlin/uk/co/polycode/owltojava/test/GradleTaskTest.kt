package uk.co.polycode.owltojava.test

import mu.KotlinLogging
import org.simpleframework.xml.Serializer
import org.simpleframework.xml.core.Persister
import uk.co.polycode.owltojava.*
import uk.co.polycode.owltojava.rdf.RdfDocument
import java.io.BufferedReader
import java.io.File
import java.math.BigDecimal
import java.math.BigInteger
import java.net.URL
import java.nio.file.Paths
import java.time.ZonedDateTime
import java.util.regex.Pattern
import kotlin.test.*

private val logger = KotlinLogging.logger {}

/**
 * OWL to Java generates Source Code from the W3C Web Ontology Language (OWL)
 * Copyright (C) 2022  Antony Cartwright, Polycode Limited
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * Mozilla Public License, v. 2.0 for more details.
 */
internal class GradleTaskTest {

    private val srcTestResources = ".${File.separator}src${File.separator}test${File.separator}resources"
    private val minimalOwlFilePath = srcTestResources.plus("${File.separator}schemaorg-minimal-person.owl")
    private val wholeOwlFilePath = srcTestResources.plus("${File.separator}schemaorg.owl")
    private val javaSourceDirectoryPath = ".${File.separator}build${File.separator}generated-sources"
    private val javaBasePackage = "uk.co.polycode"
    private val licenceText = """
        This file was generated by OWL to Java as a transformation of the Schema.org schema Version 14.0.
        Schema.org is released under the Creative Commons Attribution-ShareAlike License (version 3.0). 
        The Schema.org license is applicable to the generated source files and the license is available from 
        https://creativecommons.org/licenses/by-sa/3.0/
        """.trimIndent()
    private val lang = "en"
    private val classes = listOf(
        "https://schema.org/Person",
        "https://schema.org/City",
        "https://schema.org/Place",
        "https://schema.org/Corporation",
        "https://schema.org/Project",
        "https://schema.org/Book",
        "https://schema.org/Article",
        "https://example.com/NoLang",
        "https://schema.org/Fake"
    )
    private val primitivePropertyTypes = mapOf(
        "https://schema.org/DataType" to Object::class.java.name,
        "https://schema.org/Text"     to String::class.java.name,
        "https://schema.org/Time"     to ZonedDateTime::class.java.name,
        "https://schema.org/DateTime" to ZonedDateTime::class.java.name,
        "https://schema.org/Date"     to ZonedDateTime::class.java.name,
        "https://schema.org/URL"      to URL::class.java.name,
        "https://schema.org/Integer"  to BigInteger::class.java.name,
        "https://schema.org/Float"    to BigDecimal::class.java.name,
        "https://schema.org/Number"   to BigDecimal::class.java.name,
        "https://schema.org/Boolean"  to "java.lang.Boolean", // Boolean::class.java.name, unboxes to boolean.
    )
    private val ignoredPropertyTypes = listOf(
        "https://schema.org/Role"
    )
    private val prunedPropertyTypes = listOf(
        "https://schema.org/Text",
        "https://schema.org/URL"
    )
    private val ignoredSuperclasses = listOf(
        "http://www.w3.org/2000/01/rdf-schema#Class"
    )

    @Test
    fun testJavaSourceFileInOutput() {

        // Expected results
        val expectedClassName = "Person"
        val expectedSuperclassName = "Thing"
        val expectedOutputFilePath = "${javaSourceDirectoryPath}/uk/co/polycode/org/schema/${expectedClassName}.java"
        val expectedOutputFile = Paths.get(expectedOutputFilePath).toFile()

        // Setup
        val owlFile = File(wholeOwlFilePath)
        val serializer: Serializer = Persister()
        val workingDirectory = System.getProperty("user.dir")
        logger.debug("Working Directory = ${workingDirectory}}")
        val rdfDocument: RdfDocument = serializer.read(RdfDocument::class.java, owlFile, false)
        val owlParser = OwlParser(
            rdfDocument = rdfDocument,
            lang = lang,
            classes = classes,
            ignoredPropertyTypes = ignoredPropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes
        )
        val javaSourceBuilder = JavaSourceBuilder(
            lang = lang,
            javaBasePackage = javaBasePackage,
            licenceText = licenceText,
            desiredClasses = classes,
            primitivePropertyTypes = primitivePropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes,
            ignoredSuperclasses = ignoredSuperclasses
        )

        // Execution
        val ontologyClasses = owlParser.buildClassMap().filter { it.key.id !in primitivePropertyTypes.keys }
        val outputDir = File(javaSourceDirectoryPath)
        val javaSourceWriter = JavaSourceWriter()
        javaSourceWriter.writeClassMapAsJavaSource(
            javaSourceDirectoryPath,
            outputDir,
            ontologyClasses,
            javaSourceBuilder
        )

        // Class validation
        assertTrue(expectedOutputFile.exists())
        val bufferedReader: BufferedReader = expectedOutputFile.bufferedReader()
        val javaSourceFile = bufferedReader.use { it.readText() }
        assertTrue { javaSourceFile.contains("public class ${expectedClassName}") }
        assertTrue {
            javaSourceFile.contains(
                "public class ${expectedClassName} extends ${expectedSuperclassName} {"
            )
        }
        assertTrue {
            javaSourceFile.contains(
                "public String isDefinedBy = \"https://schema.org/${expectedClassName}\";"
            )
        }
        assertTrue { javaSourceFile.contains("public String additionalName;") }
        assertTrue { javaSourceFile.contains("public PostalAddress address;") }
        assertTrue { javaSourceFile.contains("public Person funder;") }
        assertTrue { javaSourceFile.contains("public Organization funderOrganization;") }
        assertTrue { javaSourceFile.contains("public ZonedDateTime birthDate;") }
        assertTrue { javaSourceFile.contains("public String telephone;") }
        assertTrue { javaSourceFile.contains("public QuantitativeValue weight;") }
    }

    @Test
    fun testJavaSourceFileNotWritten() {

        // Expected results
        val expectedClassName = "Person"
        val expectedOutputFilePath = "${javaSourceDirectoryPath}/do/not/reuse/between/tests/${expectedClassName}.java"
        val expectedOutputFile = Paths.get(expectedOutputFilePath).toFile()

        val taskDelegate = RegenerateOntologyTaskDelegate(
            lang = lang,
            src = minimalOwlFilePath,
            dest = "",
            javaBasePackage = javaBasePackage,
            licenceText = licenceText,
            classes = classes,
            primitivePropertyTypes = primitivePropertyTypes,
            ignoredPropertyTypes = ignoredPropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes,
            ignoredSuperclasses = ignoredSuperclasses
        )

        // Execution
        taskDelegate.regenerateJavaSource()

        // Primitive validation
        assertTrue(!expectedOutputFile.exists())
    }

    /**
     *  Gradle Task
     *  @since("Commit hash: c616f30060a429080fb516d1eb715af20865ce28")
     */
    @Test
    fun testJavaSourceFileInOutputWithPrimitives() {

        // Expected results
        val expectedClass = "Place"
        val outputFilePath = "${javaSourceDirectoryPath}/uk/co/polycode/org/schema/${expectedClass}.java"
        val outputFile = Paths.get(outputFilePath).toFile()

        // Setup
        val taskDelegate = RegenerateOntologyTaskDelegate(
            lang = lang,
            src = wholeOwlFilePath,
            dest = javaSourceDirectoryPath,
            javaBasePackage = javaBasePackage,
            licenceText = licenceText,
            classes = classes,
            primitivePropertyTypes = primitivePropertyTypes,
            ignoredPropertyTypes = ignoredPropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes,
            ignoredSuperclasses = ignoredSuperclasses
        )

        // Execution
        taskDelegate.regenerateJavaSource()

        // Validation
        assertTrue(outputFile.exists())
        val bufferedReader: BufferedReader = outputFile.bufferedReader()
        val javaSourceFile = bufferedReader.use { it.readText() }
        assertTrue { javaSourceFile.contains("public class ${expectedClass}") }
        assertTrue { javaSourceFile.contains("public GeoShape geoGeoShape;") }
        assertTrue { javaSourceFile.contains("public PostalAddress address;") }
        assertTrue { javaSourceFile.contains("public DefinedTerm keywords;") }
        assertTrue { javaSourceFile.contains("public BigDecimal latitude;") }
        assertTrue { javaSourceFile.contains("public BigDecimal longitude;") }
        assertTrue { javaSourceFile.contains("public OpeningHoursSpecification openingHoursSpecification;") }
        assertTrue { javaSourceFile.contains("public Photograph photo;") }
        assertTrue { javaSourceFile.contains("public ImageObject photoImageObject;") }
        assertTrue { javaSourceFile.contains("public BigInteger maximumAttendeeCapacity;") }
        assertTrue { javaSourceFile.contains("public Boolean publicAccess;") }
    }

    /**
     * Test detects duplicated field names where the field name is generated from 2 classes mapped to the same primitive
     *
     * /Users/antony/projects/libschemaorg/src/main/java/uk/co/polycode/schemaorg/org/schema/Offer.java:347:
     * error:
     * variable availabilityEndsZonedDateTime is already defined in class uk.co.polycode.schemaorg.org.schema.Offer
     * public ZonedDateTime availabilityEndsZonedDateTime;
     *                      ^
     * /Users/antony/projects/libschemaorg/src/main/java/uk/co/polycode/schemaorg/org/schema/Offer.java:362:
     * error:
     * variable availabilityStartsZonedDateTime is already defined in class uk.co.polycode.schemaorg.org.schema.Offer
     * public ZonedDateTime availabilityStartsZonedDateTime;
     *                      ^
     */
    @Test
    fun testNoDuplicateFieldNames() {

        // Expected results
        val expectedClass = "Offer"
        val outputFilePath = "${javaSourceDirectoryPath}/uk/co/polycode/org/schema/${expectedClass}.java"
        val outputFile = Paths.get(outputFilePath).toFile()
        val expectedSingleField = "availabilityEndsZonedDateTime"

        // Setup
        val taskDelegate = RegenerateOntologyTaskDelegate(
            lang = lang,
            src = wholeOwlFilePath,
            dest = javaSourceDirectoryPath,
            javaBasePackage = javaBasePackage,
            licenceText = licenceText,
            classes = classes,
            primitivePropertyTypes = primitivePropertyTypes,
            ignoredPropertyTypes = ignoredPropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes,
            ignoredSuperclasses = ignoredSuperclasses
        )

        // Execution
        taskDelegate.regenerateJavaSource()

        // Validation
        assertTrue(outputFile.exists())
        val bufferedReader: BufferedReader = outputFile.bufferedReader()
        val javaSourceFile = bufferedReader.use { it.readText() }
        assertTrue { javaSourceFile.contains("public class ${expectedClass}") }
        assertTrue { javaSourceFile.contains(expectedSingleField) }
        //TODO: Bug - assertTrue { countMatches(javaSourceFile,Pattern.compile(expectedSingleField)) == 1 }
    }

    /**
     * Test detects illegal Superclass (which was replaced by a Primitive so not defined but still used as a superclass)
     *
     * /Users/antony/projects/libschemaorg/src/main/java/uk/co/polycode/schemaorg/org/schema/CssSelectorType.java:17:
     * error: cannot find symbol
     * public class CssSelectorType extends Text {
     *                                      ^
     * symbol: class Text
     * /Users/antony/projects/libschemaorg/src/main/java/uk/co/polycode/schemaorg/org/schema/XPathType.java:17:
     * error: cannot find symbol
     * public class XPathType extends Text {
     *                                ^
     * symbol: class Text
     */
    @Test
    fun testNoTextSuperclass() {

        // Expected results
        val expectedClass = "XPathType"
        val outputFilePath = "${javaSourceDirectoryPath}/uk/co/polycode/org/schema/${expectedClass}.java"
        val outputFile = Paths.get(outputFilePath).toFile()
        //val unexpectedSingleField = "extends Text"

        // Setup
        val taskDelegate = RegenerateOntologyTaskDelegate(
            lang = lang,
            src = wholeOwlFilePath,
            dest = javaSourceDirectoryPath,
            javaBasePackage = javaBasePackage,
            licenceText = licenceText,
            classes = classes,
            primitivePropertyTypes = primitivePropertyTypes,
            ignoredPropertyTypes = ignoredPropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes,
            ignoredSuperclasses = ignoredSuperclasses
        )

        // Execution
        taskDelegate.regenerateJavaSource()

        // Validation
        assertTrue(outputFile.exists())
        val bufferedReader: BufferedReader = outputFile.bufferedReader()
        val javaSourceFile = bufferedReader.use { it.readText() }
        assertTrue { javaSourceFile.contains("public class ${expectedClass}") }
        //TODO: Bug - assertFalse { javaSourceFile.contains(unexpectedSingleField) }
    }

    @Test
    fun testCountMatches() {

        // Expected results
        val sampleString = "AABBCCBB"
        val expectedNoMatch = "XX"
        val expectedOneMatch = "AA"
        //val expectedTwoMatch = "BB"

        // Setup

        // Execution

        // Validation
        assertEquals(0, countMatches(sampleString, Pattern.compile(expectedNoMatch)))
        assertEquals(1, countMatches(sampleString, Pattern.compile(expectedOneMatch)))
        assertEquals(0, countMatches(expectedNoMatch, Pattern.compile(expectedOneMatch)))
        // TODO: Bug - count matches doesn't work
        //  assertEquals(2, countMatches(sampleString, Pattern.compile(expectedTwoMatch)))

        //val s: String? = null
        //assertFalse("The null operator should evaluate to null, so the Elvis operator finds the false")
        //{ s?.contains("abc") ?: false }
        //assertFalse("The null operator should evaluate to null, so the Elvis operator finds \"xyz\"")
        //{ "abc".contains(s?.toString() ?: "xyz") }
        //fun String.id() = toString()
        //assertFalse("The null operator should evaluate to null, so the Elvis operator finds \"xyz\"")
        //{ "abc".contains(s?.id() ?: "xyz") }
    }

    private fun countMatches(s: String, pattern: Pattern) =
        s.split(pattern).dropLastWhile { it.isEmpty() }.toTypedArray().size - 1
}
