/**
 * OWL to Java generates Source Code from the W3C Web Ontology Language (OWL)
 * Copyright (C) 2022  Antony Cartwright, Polycode Limited
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * Mozilla Public License, v. 2.0 for more details.
 */
package uk.co.polycode.owltojava.test

import mu.KotlinLogging
import org.simpleframework.xml.Serializer
import org.simpleframework.xml.core.Persister
import uk.co.polycode.owltojava.JavaSourceBuilder
import uk.co.polycode.owltojava.OwlParser
import uk.co.polycode.owltojava.RegenerateOntologyTask
import uk.co.polycode.owltojava.rdf.RdfDocument
import java.io.BufferedReader
import java.io.File
import java.math.BigDecimal
import java.math.BigInteger
import java.net.URI
import java.net.URL
import java.nio.file.Paths
import java.time.ZonedDateTime
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

private val logger = KotlinLogging.logger {}

internal class GenerateJavaSourceTest {

    private val srcTestResources = ".${File.separator}src${File.separator}test${File.separator}resources"
    private val wholeOwlFilePath = srcTestResources.plus("${File.separator}schemaorg.owl")
    private val minimalOwlFilePath = srcTestResources.plus("${File.separator}schemaorg-minimal-person.owl")
    private val skeletonOwlFilePath = srcTestResources.plus("${File.separator}schemaorg-skeleton.owl")
    private val javaSourceDirectoryPath = ".${File.separator}build${File.separator}generated-sources"
    private val javaBasePackage = "uk.co.polycode"
    private val licenceText = """
        This file was generated by OWL to Java as a transformation of the Schema.org schema Version 14.0.
        Schema.org is released under the Creative Commons Attribution-ShareAlike License (version 3.0). 
        The Schema.org license is applicable to the generated source files and the license is available from 
        https://creativecommons.org/licenses/by-sa/3.0/
        """.trimIndent()
    private val lang = "en"
    private val classes = listOf(
        "https://schema.org/Person",
        "https://schema.org/City",
        "https://schema.org/Place",
        "https://schema.org/Corporation",
        "https://schema.org/Project",
        "https://schema.org/Book",
        "https://schema.org/Article",
        "https://example.com/NoLang",
        "https://schema.org/Fake"
    )
    private val primitivePropertyTypes = mapOf(
        "https://schema.org/DataType" to Object::class.java.name,
        "https://schema.org/Text"     to String::class.java.name,
        "https://schema.org/Time"     to ZonedDateTime::class.java.name,
        "https://schema.org/DateTime" to ZonedDateTime::class.java.name,
        "https://schema.org/Date"     to ZonedDateTime::class.java.name,
        "https://schema.org/URL"      to URL::class.java.name,
        "https://schema.org/Integer"  to BigInteger::class.java.name,
        "https://schema.org/Float"    to BigDecimal::class.java.name,
        "https://schema.org/Number"   to BigDecimal::class.java.name,
        "https://schema.org/Boolean"  to "java.lang.Boolean", // Boolean::class.java.name, unboxes to boolean.
    )
    private val ignoredPropertyTypes = listOf(
        "https://schema.org/Role"
    )
    private val prunedPropertyTypes = listOf(
        "https://schema.org/Text",
        "https://schema.org/URL"
    )
    private val ignoredSuperclasses = listOf<String>(
        "http://www.w3.org/2000/01/rdf-schema#Class"
    )

    @Test
    fun testExpectClassNameFromPath() {

        // Expected results
        val expectedClassName = "Person"

        // Setup

        // Execution
        val actualClassName = JavaSourceBuilder.classNameForPath("${expectedClassName}")
        val actualClassNameConverted = JavaSourceBuilder.toTitleCase(actualClassName.uppercase())

        // Validation
        assertTrue { actualClassName.contains("${expectedClassName}") }
        assertEquals(actualClassNameConverted, expectedClassName)
    }

    @Test
    fun testExpectClassNameFromId() {

        // Expected results
        val expectedClassName = "Person"
        val expectedSuperclassName = "Thing"

        // Setup
        val owlFile = File(skeletonOwlFilePath)
        val serializer: Serializer = Persister()
        val workingDirectory = System.getProperty("user.dir")
        logger.debug("Working Directory = ${workingDirectory}}")
        val rdfDocument: RdfDocument = serializer.read(RdfDocument::class.java, owlFile, false)
        val owlParser = OwlParser(
            rdfDocument = rdfDocument,
            lang = lang,
            classes = classes,
            ignoredPropertyTypes = ignoredPropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes
        )

        // Execution
        val ontologyClasses = owlParser.buildClassMap().filter { it.key.id !in primitivePropertyTypes.keys }
        val owlExpectedClass = ontologyClasses.keys.firstOrNull { it.id.contains(expectedClassName) }
        val owlExpectedProperties = ontologyClasses[owlExpectedClass]
        assertNotNull(owlExpectedClass)
        assertNotNull(owlExpectedProperties)
        val actualClassName = JavaSourceBuilder.classNameForUri(URI(owlExpectedClass.id))
        val actualSuperClassIds = owlExpectedClass.subClassesOf?.map {it.resource} ?: emptyList<String>()
        val actualSuperclassName = JavaSourceBuilder.classNameForUri(URI(actualSuperClassIds.firstOrNull() ?: ""))
        val nullString: String? = null

        // Validation
        assertTrue { nullString?.contains("this string is not evaluated") ?: true }
        assertTrue { actualClassName.contains("${expectedClassName}") }
        assertTrue { actualSuperclassName.contains("${expectedSuperclassName}") }
    }

    @Test
    fun testExpectClassToBeGenerated() {

        // Expected results
        val expectedClass = "Person"
        val expectedClassLabel = "A person (alive, dead, undead, or fictional)."

        // Setup
        val owlFile = File(minimalOwlFilePath)
        val serializer: Serializer = Persister()
        val workingDirectory = System.getProperty("user.dir")
        logger.debug("Working Directory = ${workingDirectory}}")
        val rdfDocument: RdfDocument = serializer.read(RdfDocument::class.java, owlFile, false)
        val owlParser = OwlParser(
            rdfDocument = rdfDocument,
            lang = lang,
            classes = classes,
            ignoredPropertyTypes = ignoredPropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes
        )
        val javaSourceBuilder = JavaSourceBuilder(
            lang = lang,
            javaBasePackage = javaBasePackage,
            licenceText = licenceText,
            desiredClasses = classes,
            primitivePropertyTypes = primitivePropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes,
            ignoredSuperclasses = ignoredSuperclasses
        )

        // Execution
        val ontologyClasses = owlParser.buildClassMap().filter { it.key.id !in primitivePropertyTypes.keys }
        val owlExpectedClass = ontologyClasses.keys.firstOrNull { it.id.contains(expectedClass)}
        val owlExpectedProperties = ontologyClasses[owlExpectedClass]
        assertNotNull(owlExpectedClass)
        assertNotNull(owlExpectedProperties)
        val javaSource = javaSourceBuilder.build(owlExpectedClass, owlExpectedProperties)

        // Validation
        assertTrue { javaSource.isNotBlank() && javaSource.contains("public class ${expectedClass}") }
        assertTrue { javaSource.isNotBlank() && javaSource.contains(expectedClassLabel) }
    }

    @Test
    fun testExpectNoLangClassToBeGenerated() {

        // Expected results
        val expectedClass = "NoLang"

        // Setup
        val owlFile = File(minimalOwlFilePath)
        val serializer: Serializer = Persister()
        val workingDirectory = System.getProperty("user.dir")
        logger.debug("Working Directory = ${workingDirectory}}")
        val rdfDocument: RdfDocument = serializer.read(RdfDocument::class.java, owlFile, false)
        val owlParser = OwlParser(
            rdfDocument = rdfDocument,
            lang = lang,
            classes = classes,
            ignoredPropertyTypes = ignoredPropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes
        )
        val javaSourceBuilder = JavaSourceBuilder(
            lang = lang,
            javaBasePackage = javaBasePackage,
            licenceText = licenceText,
            desiredClasses = classes,
            primitivePropertyTypes = primitivePropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes,
            ignoredSuperclasses = ignoredSuperclasses
        )

        // Execution
        val ontologyClasses = owlParser.buildClassMap().filter { it.key.id !in primitivePropertyTypes.keys }
        val owlExpectedClass = ontologyClasses.keys.firstOrNull { it.id.contains(expectedClass)}
        val owlExpectedProperties = ontologyClasses[owlExpectedClass]
        assertNotNull(owlExpectedClass)
        assertNotNull(owlExpectedProperties)
        val javaSource = javaSourceBuilder.build(owlExpectedClass, owlExpectedProperties)

        // Validation
        assertTrue { javaSource.isNotBlank() && javaSource.contains("public class ${expectedClass}") }
    }

    @Test
    fun testExpectThingWithNoLangClassToBeGenerated() {

        // Expected results
        val expectedClass = "Thing"

        // Setup
        val owlFile = File(minimalOwlFilePath)
        val serializer: Serializer = Persister()
        val workingDirectory = System.getProperty("user.dir")
        logger.debug("Working Directory = ${workingDirectory}}")
        val rdfDocument: RdfDocument = serializer.read(RdfDocument::class.java, owlFile, false)
        val owlParser = OwlParser(
            rdfDocument = rdfDocument,
            lang = lang,
            classes = classes,
            ignoredPropertyTypes = ignoredPropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes
        )
        val javaSourceBuilder = JavaSourceBuilder(
            lang = lang,
            javaBasePackage = javaBasePackage,
            licenceText = licenceText,
            desiredClasses = classes,
            primitivePropertyTypes = primitivePropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes,
            ignoredSuperclasses = ignoredSuperclasses
        )

        // Execution
        val ontologyClasses = owlParser.buildClassMap().filter { it.key.id !in primitivePropertyTypes.keys }
        val owlExpectedClass = ontologyClasses.keys.firstOrNull { it.id.contains(expectedClass)}
        val owlExpectedProperties = ontologyClasses[owlExpectedClass]
        assertNotNull(owlExpectedClass)
        assertNotNull(owlExpectedProperties)
        val javaSource = javaSourceBuilder.build(owlExpectedClass, owlExpectedProperties)

        // Validation
        assertTrue { javaSource.isNotBlank() && javaSource.contains("public NoLang nolangproperty;") }
    }

    @Test
    fun testJavaSourceFileInOutput() {

        // Expected results
        val expectedClassName = "Person"
        val expectedSuperclassName = "Thing"
        val expectedOutputFilePath = "${javaSourceDirectoryPath}/uk/co/polycode/org/schema/${expectedClassName}.java"
        val expectedOutputFile = Paths.get(expectedOutputFilePath).toFile()

        // Setup
        val owlFile = File(wholeOwlFilePath)
        val serializer: Serializer = Persister()
        val workingDirectory = System.getProperty("user.dir")
        logger.debug("Working Directory = ${workingDirectory}}")
        val rdfDocument: RdfDocument = serializer.read(RdfDocument::class.java, owlFile, false)
        val owlParser = OwlParser(
            rdfDocument = rdfDocument,
            lang = lang,
            classes = classes,
            ignoredPropertyTypes = ignoredPropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes
        )
        val javaSourceBuilder = JavaSourceBuilder(
            lang = lang,
            javaBasePackage = javaBasePackage,
            licenceText = licenceText,
            desiredClasses = classes,
            primitivePropertyTypes = primitivePropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes,
            ignoredSuperclasses = ignoredSuperclasses
        )

        // Execution
        val ontologyClasses = owlParser.buildClassMap().filter { it.key.id !in primitivePropertyTypes.keys }
        val outputDir = File(javaSourceDirectoryPath)
        RegenerateOntologyTask.writeClassMapAsJavaSource(
            javaSourceDirectoryPath,
            outputDir,
            javaBasePackage,
            ontologyClasses,
            javaSourceBuilder)

        // Class validation
        assertTrue(expectedOutputFile.exists())
        var bufferedReader: BufferedReader = expectedOutputFile.bufferedReader()
        var javaSourceFile = bufferedReader.use { it.readText() }
        assertTrue { javaSourceFile.contains("public class ${expectedClassName}") }
        assertTrue { javaSourceFile.contains(
            "public class ${expectedClassName} extends ${expectedSuperclassName} {"
        ) }
        assertTrue { javaSourceFile.contains(
            "public String isDefinedBy = \"https://schema.org/${expectedClassName}\";"
        ) }
        assertTrue { javaSourceFile.contains("public String additionalName;") }
        assertTrue { javaSourceFile.contains("public PostalAddress address;") }
        assertTrue { javaSourceFile.contains("public Person funder;") }
        assertTrue { javaSourceFile.contains("public Organization funderOrganization;") }
        assertTrue { javaSourceFile.contains("public ZonedDateTime birthDate;") }
        assertTrue { javaSourceFile.contains("public String telephone;") }
        assertTrue { javaSourceFile.contains("public QuantitativeValue weight;") }
    }

    @Test
    fun testJavaSourceFileInOutputWithPrimitives() {

        // Expected results
        val expectedClass = "Place"
        val outputFilePath = "${javaSourceDirectoryPath}/uk/co/polycode/org/schema/${expectedClass}.java"
        val outputFile = Paths.get(outputFilePath).toFile()

        // Setup
        val owlFile = File(wholeOwlFilePath)
        val serializer: Serializer = Persister()
        val workingDirectory = System.getProperty("user.dir")
        logger.debug("Working Directory = ${workingDirectory}}")
        val rdfDocument: RdfDocument = serializer.read(RdfDocument::class.java, owlFile, false)
        val owlParser = OwlParser(
            rdfDocument = rdfDocument,
            lang = lang,
            classes = classes,
            ignoredPropertyTypes = ignoredPropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes
        )
        val javaSourceBuilder = JavaSourceBuilder(
            lang = lang,
            javaBasePackage = javaBasePackage,
            licenceText = licenceText,
            desiredClasses = classes,
            primitivePropertyTypes = primitivePropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes,
            ignoredSuperclasses = ignoredSuperclasses
        )

        // Execution
        val ontologyClasses = owlParser.buildClassMap().filter { it.key.id !in primitivePropertyTypes.keys }
        val outputDir = File(javaSourceDirectoryPath)
        RegenerateOntologyTask.writeClassMapAsJavaSource(
            javaSourceDirectoryPath,
            outputDir,
            javaBasePackage,
            ontologyClasses,
            javaSourceBuilder)

        // Primitive validation
        assertTrue(outputFile.exists())
        var bufferedReader: BufferedReader = outputFile.bufferedReader()
        var javaSourceFile = bufferedReader.use { it.readText() }
        assertTrue { javaSourceFile.contains("public class ${expectedClass}") }
        assertTrue { javaSourceFile.contains(
            "public String isDefinedBy = \"https://schema.org/${expectedClass}\";"
        ) }
        assertTrue { javaSourceFile.contains("public GeoShape geoGeoShape;") }
        assertTrue { javaSourceFile.contains("public PostalAddress address;") }
        assertTrue { javaSourceFile.contains("public DefinedTerm keywords;") }
        assertTrue { javaSourceFile.contains("public BigDecimal latitude;") }
        assertTrue { javaSourceFile.contains("public BigDecimal longitude;") }
        assertTrue { javaSourceFile.contains("public OpeningHoursSpecification openingHoursSpecification;") }
        assertTrue { javaSourceFile.contains("public Photograph photo;") }
        assertTrue { javaSourceFile.contains("public ImageObject photoImageObject;") }
        assertTrue { javaSourceFile.contains("public BigInteger maximumAttendeeCapacity;") }
        assertTrue { javaSourceFile.contains("public Boolean publicAccess;") }
    }
}
