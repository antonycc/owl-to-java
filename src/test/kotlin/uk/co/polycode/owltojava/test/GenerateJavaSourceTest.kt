/**
 * OWL to Java generates Source Code from the W3C Web Ontology Language (OWL)
 * Copyright (C) 2022  Antony Cartwright, Polycode Limited
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * Mozilla Public License, v. 2.0 for more details.
 */
package uk.co.polycode.owltojava.test

import mu.KotlinLogging
import org.simpleframework.xml.Serializer
import org.simpleframework.xml.core.Persister
import uk.co.polycode.owltojava.JavaSourceBuilder
import uk.co.polycode.owltojava.OwlParser
import uk.co.polycode.owltojava.rdf.RdfDocument
import java.io.File
import java.math.BigDecimal
import java.math.BigInteger
import java.net.URI
import java.net.URL
import java.time.ZonedDateTime
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

private val logger = KotlinLogging.logger {}

internal class GenerateJavaSourceTest {

    private val srcTestResources = ".${File.separator}src${File.separator}test${File.separator}resources"
    private val minimalOwlFilePath = srcTestResources.plus("${File.separator}schemaorg-minimal-person.owl")
    private val skeletonOwlFilePath = srcTestResources.plus("${File.separator}schemaorg-skeleton.owl")
    private val javaBasePackage = "uk.co.polycode"
    private val licenceText = """
        This file was generated by OWL to Java as a transformation of the Schema.org schema Version 14.0.
        Schema.org is released under the Creative Commons Attribution-ShareAlike License (version 3.0). 
        The Schema.org license is applicable to the generated source files and the license is available from 
        https://creativecommons.org/licenses/by-sa/3.0/
        """.trimIndent()
    private val lang = "en"
    private val classes = listOf(
        "https://schema.org/Person",
        "https://schema.org/City",
        "https://schema.org/Place",
        "https://schema.org/Corporation",
        "https://schema.org/Project",
        "https://schema.org/Book",
        "https://schema.org/Article",
        "https://example.com/NoLang",
        "https://schema.org/Fake"
    )
    private val primitivePropertyTypes = mapOf(
        "https://schema.org/DataType" to Object::class.java.name,
        "https://schema.org/Text"     to String::class.java.name,
        "https://schema.org/Time"     to ZonedDateTime::class.java.name,
        "https://schema.org/DateTime" to ZonedDateTime::class.java.name,
        "https://schema.org/Date"     to ZonedDateTime::class.java.name,
        "https://schema.org/URL"      to URL::class.java.name,
        "https://schema.org/Integer"  to BigInteger::class.java.name,
        "https://schema.org/Float"    to BigDecimal::class.java.name,
        "https://schema.org/Number"   to BigDecimal::class.java.name,
        "https://schema.org/Boolean"  to "java.lang.Boolean", // Boolean::class.java.name, unboxes to boolean.
    )
    private val ignoredPropertyTypes = listOf(
        "https://schema.org/Role"
    )
    private val prunedPropertyTypes = listOf(
        "https://schema.org/Text",
        "https://schema.org/URL"
    )
    private val ignoredSuperclasses = listOf(
        "http://www.w3.org/2000/01/rdf-schema#Class"
    )

    @Test
    fun testExpectClassNameFromPath() {

        // Expected results
        val expectedClassName = "Person"

        // Setup

        // Execution
        val actualClassName = JavaSourceBuilder.classNameForPath(expectedClassName)
        val actualClassNameConverted = JavaSourceBuilder.toTitleCase(actualClassName.uppercase())

        // Validation
        assertTrue { actualClassName.contains(expectedClassName) }
        assertEquals(actualClassNameConverted, expectedClassName)
    }

    @Test
    fun testExpectClassNameFromId() {

        // Expected results
        val expectedClassName = "Person"
        val expectedSuperclassName = "Thing"

        // Setup
        val owlFile = File(skeletonOwlFilePath)
        val serializer: Serializer = Persister()
        val workingDirectory = System.getProperty("user.dir")
        logger.debug("Working Directory = ${workingDirectory}}")
        val rdfDocument: RdfDocument = serializer.read(RdfDocument::class.java, owlFile, false)
        val owlParser = OwlParser(
            rdfDocument = rdfDocument,
            lang = lang,
            classes = classes,
            ignoredPropertyTypes = ignoredPropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes
        )

        // Execution
        val ontologyClasses = owlParser.buildClassMap().filter { it.key.id !in primitivePropertyTypes.keys }
        val owlExpectedClass = ontologyClasses.keys.firstOrNull { it.id.contains(expectedClassName) }
        val owlExpectedProperties = ontologyClasses[owlExpectedClass]
        assertNotNull(owlExpectedClass)
        assertNotNull(owlExpectedProperties)
        val actualClassName = JavaSourceBuilder.classNameForUri(URI(owlExpectedClass.id))
        val actualSuperClassIds = owlExpectedClass.subClassesOf?.map {it.resource} ?: emptyList()
        val actualSuperclassName = JavaSourceBuilder.classNameForUri(URI(actualSuperClassIds.firstOrNull() ?: ""))

        // Validation
        assertTrue { actualClassName.contains(expectedClassName) }
        assertTrue { actualSuperclassName.contains(expectedSuperclassName) }
    }

    @Test
    fun testExpectClassToBeGenerated() {

        // Expected results
        val expectedClass = "Person"
        val expectedClassLabel = "A person (alive, dead, undead, or fictional)."

        // Setup
        val owlFile = File(minimalOwlFilePath)
        val serializer: Serializer = Persister()
        val workingDirectory = System.getProperty("user.dir")
        logger.debug("Working Directory = ${workingDirectory}}")
        val rdfDocument: RdfDocument = serializer.read(RdfDocument::class.java, owlFile, false)
        val owlParser = OwlParser(
            rdfDocument = rdfDocument,
            lang = lang,
            classes = classes,
            ignoredPropertyTypes = ignoredPropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes
        )
        val javaSourceBuilder = JavaSourceBuilder(
            lang = lang,
            javaBasePackage = javaBasePackage,
            licenceText = licenceText,
            desiredClasses = classes,
            primitivePropertyTypes = primitivePropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes,
            ignoredSuperclasses = ignoredSuperclasses
        )

        // Execution
        val ontologyClasses = owlParser.buildClassMap().filter { it.key.id !in primitivePropertyTypes.keys }
        val owlExpectedClass = ontologyClasses.keys.firstOrNull { it.id.contains(expectedClass)}
        val owlExpectedProperties = ontologyClasses[owlExpectedClass]
        assertNotNull(owlExpectedClass)
        assertNotNull(owlExpectedProperties)
        val javaSource = javaSourceBuilder.build(owlExpectedClass, owlExpectedProperties)

        // Validation
        assertTrue { javaSource.isNotBlank() && javaSource.contains("public class ${expectedClass}") }
        assertTrue { javaSource.isNotBlank() && javaSource.contains(expectedClassLabel) }
    }

    @Test
    fun testExpectNoLangClassToBeGenerated() {

        // Expected results
        val expectedClass = "NoLang"

        // Setup
        val owlFile = File(minimalOwlFilePath)
        val serializer: Serializer = Persister()
        val workingDirectory = System.getProperty("user.dir")
        logger.debug("Working Directory = ${workingDirectory}}")
        val rdfDocument: RdfDocument = serializer.read(RdfDocument::class.java, owlFile, false)
        val owlParser = OwlParser(
            rdfDocument = rdfDocument,
            lang = lang,
            classes = classes,
            ignoredPropertyTypes = ignoredPropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes
        )
        val javaSourceBuilder = JavaSourceBuilder(
            lang = lang,
            javaBasePackage = javaBasePackage,
            licenceText = licenceText,
            desiredClasses = classes,
            primitivePropertyTypes = primitivePropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes,
            ignoredSuperclasses = ignoredSuperclasses
        )

        // Execution
        val ontologyClasses = owlParser.buildClassMap().filter { it.key.id !in primitivePropertyTypes.keys }
        val owlExpectedClass = ontologyClasses.keys.firstOrNull { it.id.contains(expectedClass)}
        val owlExpectedProperties = ontologyClasses[owlExpectedClass]
        assertNotNull(owlExpectedClass)
        assertNotNull(owlExpectedProperties)
        val javaSource = javaSourceBuilder.build(owlExpectedClass, owlExpectedProperties)

        // Validation
        assertTrue { javaSource.isNotBlank() && javaSource.contains("public class ${expectedClass}") }
    }

    @Test
    fun testExpectThingWithNoLangClassToBeGenerated() {

        // Expected results
        val expectedClass = "Thing"

        // Setup
        val owlFile = File(minimalOwlFilePath)
        val serializer: Serializer = Persister()
        val workingDirectory = System.getProperty("user.dir")
        logger.debug("Working Directory = ${workingDirectory}}")
        val rdfDocument: RdfDocument = serializer.read(RdfDocument::class.java, owlFile, false)
        val owlParser = OwlParser(
            rdfDocument = rdfDocument,
            lang = lang,
            classes = classes,
            ignoredPropertyTypes = ignoredPropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes
        )
        val javaSourceBuilder = JavaSourceBuilder(
            lang = lang,
            javaBasePackage = javaBasePackage,
            licenceText = licenceText,
            desiredClasses = classes,
            primitivePropertyTypes = primitivePropertyTypes,
            prunedPropertyTypes = prunedPropertyTypes,
            ignoredSuperclasses = ignoredSuperclasses
        )

        // Execution
        val ontologyClasses = owlParser.buildClassMap().filter { it.key.id !in primitivePropertyTypes.keys }
        val owlExpectedClass = ontologyClasses.keys.firstOrNull { it.id.contains(expectedClass)}
        val owlExpectedProperties = ontologyClasses[owlExpectedClass]
        assertNotNull(owlExpectedClass)
        assertNotNull(owlExpectedProperties)
        val javaSource = javaSourceBuilder.build(owlExpectedClass, owlExpectedProperties)

        // Validation
        assertTrue { javaSource.isNotBlank() && javaSource.contains("public NoLang nolangproperty;") }
    }
}
